import { supabase } from '@/lib/supabase';
import { CheckoutData, Order } from '@/types/order';
import { buildApiUrl } from '@/lib/api';

const getAuthToken = async (): Promise<string | null> => {
  try {
    const {
      data: { session },
    } = await supabase.auth.getSession();
    return session?.access_token || null;
  } catch (error) {
    console.error('Error getting auth token:', error);
    return null;
  }
};

export const orderService = {
  // Create new order (supports guest checkout with null userId)
  // Uses backend API to handle emails and notifications
  async createOrder(
    checkoutData: CheckoutData,
    arg?: string | null | { userId?: string | null; customerId?: string | null }
  ) {
    const API_URL = buildApiUrl('/api');

    let userId: string | null = null;
    let customerId: string | null = null;

    if (typeof arg === 'string' || arg === null || arg === undefined) {
      userId = arg ?? null;
    } else if (typeof arg === 'object') {
      userId = arg.userId ?? null;
      customerId = arg.customerId ?? null;
    }
    
    // Calculate totals
    const subtotal = checkoutData.items.reduce((sum, item) => sum + item.subtotal, 0);
    // Handle missing delivery_option gracefully
    const baseDeliveryFee = checkoutData.adjusted_delivery_fee ?? checkoutData.delivery_option?.price ?? 0;
    const deliveryFee = Math.max(baseDeliveryFee, 0);
    const discountAmount = Math.max(checkoutData.discount_amount || 0, 0);
    const tax = Math.max(checkoutData.tax_amount ?? 0, 0);
    const total = Number((subtotal - discountAmount + deliveryFee + tax).toFixed(2));
    
    // Log warning if delivery_option is missing
    if (!checkoutData.delivery_option) {
      console.warn('⚠️ No delivery_option provided, using default delivery fee of 0');
    }

    // Order number will be generated by backend for sequential numbering
    // Frontend should not generate order number - backend handles it

    // Map items for backend
    const order_items = checkoutData.items.map((item) => {
      const isStandalone = item.category_id === 'standalone';
      return {
        product_id: isStandalone ? null : item.id,
        product_name: item.name,
        product_image: item.thumbnail,
        quantity: item.quantity,
        unit_price: item.discount_price || item.original_price,
        subtotal: item.subtotal,
        selected_variants: item.selected_variants,
        standalone_source_id: isStandalone ? item.id : null,
      };
    });

    // Try to call backend API first, fallback to Supabase if it fails
    const orderPayload = {
      user_id: userId,
      customer_id: customerId,
      subtotal,
      discount: discountAmount,
      discount_code: checkoutData.discount_code || null,
      tax,
      delivery_fee: deliveryFee,
      total,
      payment_method: checkoutData.payment_method,
      delivery_address: checkoutData.delivery_address,
      delivery_option: checkoutData.delivery_option
        ? { ...checkoutData.delivery_option, price: deliveryFee }
        : undefined,
      notes: checkoutData.notes || null,
      payment_reference: checkoutData.payment_reference || null,
      order_items,
      tax_rate: checkoutData.tax_rate ?? null,
      tax_breakdown: checkoutData.tax_breakdown && checkoutData.tax_breakdown.length > 0
        ? checkoutData.tax_breakdown
        : undefined,
    };

    console.log('Creating order via backend API:', {
      API_URL,
      endpoint: `${API_URL}/orders`,
      payload: {
        ...orderPayload,
        order_items: orderPayload.order_items.map((item) => ({
          product_id: item.product_id,
          quantity: item.quantity,
          unit_price: item.unit_price,
        })),
      },
    });

    const authToken = await getAuthToken();

    const response = await fetch(`${API_URL}/orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
      },
      body: JSON.stringify(orderPayload),
    });

    console.log('Backend API response:', {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
    });

    if (!response.ok) {
      let errorMessage = 'Backend API failed';
      try {
        const errorData = await response.json();
        errorMessage = errorData.message || errorData.error || errorMessage;
        console.error('Backend API error response:', {
          status: response.status,
          statusText: response.statusText,
          error: errorData,
        });
      } catch (parseError) {
        errorMessage = `HTTP ${response.status}: ${response.statusText || 'Unknown error'}`;
        console.error('Backend API error (non-JSON):', {
          status: response.status,
          statusText: response.statusText,
        });
      }
      throw new Error(errorMessage);
    }

    const result = await response.json();
    if (result.success && result.data) {
      return result.data as Order;
    }

    throw new Error(result.message || 'Order creation failed');
  },

  // Get user orders
  async getUserOrders(userId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return data || [];
  },

  // Get order by ID
  async getOrderById(orderId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('id', orderId)
      .single();

    if (error) throw error;

    return data;
  },

  // Get order by order number
  async getOrderByNumber(orderNumber: string) {
    const { data, error } = await supabase
      .from('orders')
      .select('*, items:order_items(*)')
      .eq('order_number', orderNumber)
      .single();

    if (error) throw error;

    return data;
  },

  // Update order status (Admin)
  async updateOrderStatus(orderId: string, status: string) {
    const { data, error } = await supabase
      .from('orders')
      .update({ status })
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Update payment status
  async updatePaymentStatus(orderId: string, paymentStatus: string, reference?: string) {
    const updates: any = { payment_status: paymentStatus };
    
    if (reference) {
      updates.payment_reference = reference;
    }

    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', orderId)
      .select()
      .single();

    if (error) throw error;

    return data;
  },

  // Get all orders (Admin)
  async getAllOrders(page: number = 1, limit: number = 20) {
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const { data, error, count } = await supabase
      .from('orders')
      .select('*, items:order_items(*), user:users(full_name, email)', { count: 'exact' })
      .range(from, to)
      .order('created_at', { ascending: false });

    if (error) throw error;

    return {
      orders: data || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        totalPages: Math.ceil((count || 0) / limit),
      },
    };
  },

  // Cancel order (customer or admin)
  async cancelOrder(orderId: string, reason?: string) {
    const authToken = await getAuthToken();
    if (!authToken) {
      throw new Error('You must be logged in to cancel an order.');
    }

    const endpoint = buildApiUrl(`/api/orders/${orderId}/cancel`);
    const response = await fetch(endpoint, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${authToken}`,
      },
      body: JSON.stringify({
        cancellation_reason: reason || 'Cancelled by customer',
      }),
    });

    const result = await response.json();

    if (!response.ok || !result.success) {
      const message =
        result?.message || result?.error || `Failed to cancel order (${response.status})`;
      throw new Error(message);
    }

    return result.data as Order;
  },
};


